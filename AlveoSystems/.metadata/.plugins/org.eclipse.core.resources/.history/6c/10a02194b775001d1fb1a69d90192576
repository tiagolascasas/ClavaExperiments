#include <chrono>
#include <iostream>
#include <cmath>
#include "OCL_Helpers.hpp"
extern  void scheduler(float ops[], bool & executeOnCPU, bool & executeOnFPGA, bool & lowConfidence) ;
extern  void train(float ops[], bool CPUwonFPGAlost) ;
extern cl::Kernel krnl_foo;
extern cl::Kernel krnl_bar;
extern cl::CommandQueue q;
extern cl::Context context;
using namespace std::chrono;
using namespace std;
void foo_KernelCount(int *X, int *res, float ops[]) {
   ops[4] = 10000;
   ops[5] = 5000;
}

#pragma clava kernel

#pragma clava data kernel : [{auto : "auto" }, {scalar : "auto" }, {auto : "auto" }]

void foo(int *X, int *res) {
   bool executeOnCPU;
   bool executeOnFPGA;
   bool measurePerf;
   std::chrono::high_resolution_clock::duration clava_timing_duration_0;
   std::chrono::high_resolution_clock::duration clava_timing_duration_1;
   float opsCount[16];
   foo_KernelCount(X, res, opsCount);
   scheduler(opsCount, executeOnCPU, executeOnFPGA, measurePerf);
   if(executeOnCPU) {
      std::chrono::high_resolution_clock::time_point clava_timing_start_0;
      std::chrono::high_resolution_clock::time_point clava_timing_end_0;
      if(measurePerf) {
         clava_timing_start_0 = std::chrono::high_resolution_clock::now();
      }
      foo_Kernel(X, res);
      if(measurePerf) {
         clava_timing_end_0 = std::chrono::high_resolution_clock::now();
         clava_timing_duration_0 = clava_timing_end_0 - clava_timing_start_0;
      }
   }
   if(executeOnFPGA) {
      std::chrono::high_resolution_clock::time_point clava_timing_start_1;
      std::chrono::high_resolution_clock::time_point clava_timing_end_1;
      if(measurePerf) {
         clava_timing_start_1 = std::chrono::high_resolution_clock::now();
      }
      cl::Buffer buffer_X(context, CL_MEM_USE_HOST_PTR | CL_MEM_READ_WRITE, sizeof(int *), X);
      krnl_foo.setArg(0, buffer_X);
      krnl_foo.setArg(1, res);
      q.enqueueMigrateMemObjects({buffer_X}, 0 /* 0 means from host */);
      q.enqueueTask(krnl_foo);
      q.finish();
      q.enqueueMigrateMemObjects({buffer_X}, CL_MIGRATE_MEM_OBJECT_HOST);
      q.finish();
      if(measurePerf) {
         clava_timing_end_1 = std::chrono::high_resolution_clock::now();
         clava_timing_duration_1 = clava_timing_end_1 - clava_timing_start_1;
      }
   }
   if(measurePerf) train(opsCount, clava_timing_duration_0 < clava_timing_duration_1);
}

void bar_KernelCount(int *X, int *Y, int *Z, int *res, float ops[]) {
   ops[4] = 10000;
}

#pragma clava kernel

#pragma clava data kernel : [{auto : "auto" }, {auto : "auto" }, {auto : "auto" }, {scalar : "auto" }, {auto : "auto" }]

void bar(int *X, int *Y, int *Z, int *res) {
   bool executeOnCPU;
   bool executeOnFPGA;
   bool measurePerf;
   std::chrono::high_resolution_clock::duration clava_timing_duration_2;
   std::chrono::high_resolution_clock::duration clava_timing_duration_3;
   float opsCount[16];
   bar_KernelCount(X, Y, Z, res, opsCount);
   scheduler(opsCount, executeOnCPU, executeOnFPGA, measurePerf);
   if(executeOnCPU) {
      std::chrono::high_resolution_clock::time_point clava_timing_start_2;
      std::chrono::high_resolution_clock::time_point clava_timing_end_2;
      if(measurePerf) {
         clava_timing_start_2 = std::chrono::high_resolution_clock::now();
      }
      bar_Kernel(X, Y, Z, res);
      if(measurePerf) {
         clava_timing_end_2 = std::chrono::high_resolution_clock::now();
         clava_timing_duration_2 = clava_timing_end_2 - clava_timing_start_2;
      }
   }
   if(executeOnFPGA) {
      std::chrono::high_resolution_clock::time_point clava_timing_start_3;
      std::chrono::high_resolution_clock::time_point clava_timing_end_3;
      if(measurePerf) {
         clava_timing_start_3 = std::chrono::high_resolution_clock::now();
      }
      cl::Buffer buffer_X(context, CL_MEM_USE_HOST_PTR | CL_MEM_READ_WRITE, sizeof(int *), X);
      krnl_bar.setArg(0, buffer_X);
      cl::Buffer buffer_Y(context, CL_MEM_USE_HOST_PTR | CL_MEM_READ_WRITE, sizeof(int *), Y);
      krnl_bar.setArg(1, buffer_Y);
      cl::Buffer buffer_Z(context, CL_MEM_USE_HOST_PTR | CL_MEM_READ_WRITE, sizeof(int *), Z);
      krnl_bar.setArg(2, buffer_Z);
      krnl_bar.setArg(3, res);
      q.enqueueMigrateMemObjects({buffer_X, buffer_Y, buffer_Z}, 0 /* 0 means from host */);
      q.enqueueTask(krnl_bar);
      q.finish();
      q.enqueueMigrateMemObjects({buffer_X, buffer_Y, buffer_Z}, CL_MIGRATE_MEM_OBJECT_HOST);
      q.finish();
      if(measurePerf) {
         clava_timing_end_3 = std::chrono::high_resolution_clock::now();
         clava_timing_duration_3 = clava_timing_end_3 - clava_timing_start_3;
      }
   }
   if(measurePerf) train(opsCount, clava_timing_duration_2 < clava_timing_duration_3);
}

int main_original() {
   int res = 0;
   int A[1000] = {0};
   auto start = high_resolution_clock::now();
   foo(A, &res);
   auto stop = high_resolution_clock::now();
   auto duration = duration_cast<microseconds>(stop - start);
   cout << "{" << 1000 << "} : " << duration.count() << endl;
   int B[1000] = {0};
   int C[1000] = {0};
   int D[1000] = {0};
   start = high_resolution_clock::now();
   bar(B, C, D, &res);
   stop = high_resolution_clock::now();
   duration = duration_cast<microseconds>(stop - start);
   cout << "{" << 1000 << "," << 1000 << "," << 1000 << "} : " << duration.count() << endl;
   int E[100000] = {0};
   start = high_resolution_clock::now();
   foo(E, &res);
   stop = high_resolution_clock::now();
   duration = duration_cast<microseconds>(stop - start);
   cout << "{" << 100000 << "} : " << duration.count() << endl;
   int F[100000] = {0};
   int G[100000] = {0};
   int H[100000] = {0};
   start = high_resolution_clock::now();
   bar(F, G, H, &res);
   stop = high_resolution_clock::now();
   duration = duration_cast<microseconds>(stop - start);
   cout << "{" << 100000 << "," << 100000 << "," << 100000 << "} : " << duration.count() << endl;
   int I[1000000] = {0};
   start = high_resolution_clock::now();
   foo(I, &res);
   stop = high_resolution_clock::now();
   duration = duration_cast<microseconds>(stop - start);
   cout << "{" << 1000000 << "} : " << duration.count() << endl;
   int J[1000000] = {0};
   int K[1000000] = {0};
   int L[1000000] = {0};
   start = high_resolution_clock::now();
   bar(J, K, L, &res);
   stop = high_resolution_clock::now();
   duration = duration_cast<microseconds>(stop - start);
   cout << "{" << 1000000 << "," << 1000000 << "," << 1000000 << "} : " << duration.count() << endl;
   
   return 0;
}
